                   =========================================
                                    C64ASM
                   =========================================

                 COMMODORE 64 (6510) ASSEMBLER PACKAGE FOR PC
                                  Version 1.1a

                     Copyright (c) 1993-2001 by B lint T¢th

                                 DOCUMENTATION

 ============================================================================

  Contents
  --------
  1. Introduction
  2. Registration and Distribution Information
  3. Using the Assembler (C64ASM)
      3.1. DOS Error Codes
  4. Assembly Language
      4.1. Overview
      4.2. Mathemathical Expressions
      4.3. Using Symbolic Names and the * Sign
      4.4. Special Directives
  5. Using the Disassembler (C64DISA)
      5.1. Map file format
  6. Using the BAS2TXT Utility
  7. Revision History
  8. Planned Features in a Next Release
  9. Other Programs Available from the Same Author
  10. Contacting the Author

  1. Introduction
  ---------------
    C64ASM is a Commodore 64 (6510) Assembler Package for PC. It contains
    several standalone programs that are in very close relation, that is why
    they are distributed together as one single program package.

    Unlike its previous releases, the package is being distributed as FREEWARE.
    See next chapter for legal information.

    C64ASM itself is an assembler for Commodore 64's CPU, the 6510. It creates
    files in Commodore 64's machine language, but the assembler program
    itself runs on a DOS based PC. It supports labels, symbolic constants,
    mathematical expressions, include files and can create a detailed report.

    C64DISA is a disassembler, so it takes a Commodore 64 binary file
    (which was previously generated by C64ASM, or was converted directly from
    C64) and lists the machine language instructions in it. Alternatively it
    can create hexadecimal or ascii dumps, too.

    BAS2TXT converts files in CBM BASIC format (pointers to next line, line
    numbers and tokenized line contents) to plain ascii textfiles. If you
    have C64 assembly source files in that format, you should convert them to
    textfile, so C64ASM can assemble them.

    All programs support the PRG, T64 and P00 file formats.
    The PRG format is very simple: it contains the two byte start address in
    the C64's memory (in low byte + high byte order), followed by the binary
    image of the C64 file. The T64 tape file format was introduced by the
    C64 emulator called "C64S", and the P00 format by "Personal C64".

    This release of the program package contains C64SRC.ZIP, the assembly
    source files of two Commodore 64 programs I wrote 5-6 years ago. This
    archive file is also FREEWARE. See also the separate
    documentation in that package.

    Note: Many Commodore computers use the 65XX family of processors.
    C64ASM/C64DISA can be used for assembling and disassembling for any
    computer that is machine-language compatible with C64 (e.g. VIC-20, C16,
    Plus-4). I call my program C64ASM only because I have C64, I focus on
    C64, and I tested it exclusively with C64 programs and C64 emulators.

    The programs of this package run on any IBM PC or compatible computer,
    under MS-DOS 3.30 or newer operating system. They need about 140-220 kbytes
    of free (conventional) memory.
    The program also runs as a DOS application under Windows 95/98/ME/NT.
    Running under Windows XP is not tested but should be fine.

    Note: Commodore 64 is registered trademark of Commodore Business
          Machines, Inc.

  2. Legal and Distribution Information
  -------------------------------------
    This program is being distributed as FREEWARE. It means that you may use
    the program free of charge. However, if you insist to send donations, you
    may do so by sending the choosen amount to my address. (See at the end of
    this document.) Postcards are also kindly appreciated. Or just an email,
    saying that you use (or used) this software.

    The distribution files of the program package are:
        FILE_ID .DIZ     Short program description
        C64ASM  .DOC     Program documentation/manual
        C64ASM  .EXE     Commodore 64 (6510) Assembler
        C64DISA .EXE     Commodore 64 (6510) DisAssembler
        BAS2TXT .EXE     Commodore 64 BASIC to PC ASCII File Converter
        SYSTEM  .ASM     Simple C64 assembly source file
        MIRROR  .ASM     Simple C64 assembly source file
        ROTATEL .ASM     Simple C64 assembly source file
        IFGOTO  .ASM     Simple C64 assembly source file
        PRINT   .ASM     Simple C64 assembly source file
        HELLOW  .ASM     Simple C64 assembly source file
        MAIN    .ASM     Simple C64 assembly source file
        C64SRC  .ZIP     Assembly source files of two C64 programs

    The program package, which MUST include all the above files may be freely
    copied and distributed. These files may be re-archived to better suit a
    given distribution system, but the files may not be modified in any other
    way. No distributor may charge more than $5 for the distribution of this
    program. Uploading to BBSs or FTP sites or distribution on CD-ROMs are
    accepted and encouraged.

    The most recent version of this program is available on the Web at:
      http://members.chello.hu/toth.balint/software

  3. Using the Assembler (C64ASM)
  -------------------------------
    If you start C64ASM without arguments, you will get a brief help
    about the available options.
    Options can be given preceded by / or - , except input and output
    filenames, which must be given without / or -.
    Lower and upper case letters mean the same.
    Multiple options can be given in a line.
    Each group of options must start with a / or - and must not contain spaces.
    The groups must be separated by one or more spaces.
    The order of options is unsignificant.

    Usage:  C64ASM sourcefilename[.ASM] [outputfilename[.PRG]] [options]

    Options:
     /S                        write symbol table to reportfile
     /L                        write compiling list to reportfile
     /M                        write memory map to mapfile
     /T                        write summary to reportfile
     /R=reportfilename[.REP]   define other name for reportfile
     /M=mapfilename[.MAP]      define other name for mapfile
     /6                        enforce T64 file format for outputfile
     /0                        enforce P00 file format for outputfile

    The name of the assembly source file is mandatory, all other are optional.
    If you don't specify output filename, the base name of the source file
    will be used with a .PRG extension. The default extension for source file
    is .ASM and for output file is .PRG.
    If you specify .T64 as extension of the output file, the T64 tape file
    format will be used with only one C64 file in it: your compiled program.
    If you specify .P00 as extension of the output file, the P00 file
    format will be used. Otherwise PRG format will be used.
    You can override this default behavour with the /6 option. When specified,
    C64ASM will always create a T64 tape file with T64 extension regardless
    to what extension was given in the command line. Similarly, the /0 option
    enforces the P00 file format. If both /6 and /0 options are given, the /6
    option will be stronger.
    When you load the compiled program in an emulator, like C64S, don't forget
    the ,1,1 parameter (like: LOAD"",1,1) otherwise it won't be loaded to the
    right memory location. Start your program with the appropriate SYS command.

    If any of the /S, /L or /T option is given, a report file will be also
    generated. This report can be viewed by any ascii text viewer.
    The default name of the report file is the same as the source
    with .REP extension. However, you can override this with the /R=filename
    option. If you use /R=filename but don't give any of /S, /L or /T, then
    only /T option will be used. The single /R option (without a filename) is
    a single shortcut for /S /L /M /T.
    With the /M option, you can create a memory map in a special text file,
    called the map file. It can be used later by C64DISA. The default name
    of the map file is the same as the source with .MAP extension, but you
    can override this, too, with the /M=filename option. If you create a
    report file, a copy of the memory map will be written in the report
    file as well. See Section 5.1 for details of the map file format.

    If the source file cannot be compiled, a line indicating the type of
    the error is displayed. If the error occured in the first pass of
    compiling, then no reportfile will be generated, even if it is set in the
    command line.

    Examples:
        C64ASM main /SLMT
                               Compiles main.asm to main.prg, and
                               writes most detailed report to main.rep,
                               memory map is also written to main.map
        C64ASM -t rotatel output.t64 /r=summary.txt
                               Compiles rotatel.asm to output.t64 tape file,
                               and writes summary to summary.txt

  3.1. DOS Error Codes
  --------------------
    C64ASM returns a standard DOS error code, that can be checked after
    it ended the compiling. (E.g. with an "IF ERRORLEVEL" statement in a
    batch file) A zero value means that there were no errors, 1-20 are
    reserved for warnings (successful compile but there were some problems),
    21-40 are for critical errors, values 41- are for compiler errors.

    Current error codes:
       0: No Error

      21: Error in command-line parameters or /H was used
      22: Out of memory (very unlikely in real situations.)
      23: Cannot open input file (assembly source)
      24: Cannot create output file

      41: Error in expression
      42: Constant too large
      43: ) expected
      44: Operand expected
      45: Undefined symbol
      46: Expression expected
      47: Redefinition of existing constant or label
      48: Syntax error
      49: Division by zero
      50: Invalid addressing mode for this instruction
      51: Byte operand expected
      52: Branch out of range
      53: Invalid compiler directive
      54: Invalid parameter
      55: Error in include file
      56: Endless loop in include file calls
      57: Cannot open include file
      58: Possible endless loop with .GOTO or .IF

  4. Assembly Language
  --------------------

  4.1. Overview
  -------------
    The assembler supports all documented instructions and address modes of
    the Commodore 64's CPU, the 6510.
    The assembler is completely case insensitive, so upper and lower case
    letters mean the same.

    Each line in the assembly source file can contain one machine language
    instruction. The basic outline is:
        [label] mnemonic [arguments] [; remark]
    where [ ] means optionality.

    The assembler treats everything after a semicolon as remark and ignores it.
    Remarks can be given in separate lines, too.
    Labels are symbolic names of a memory location. There are global and
    local variables, the later ones are distinguished by their first
    character which is an underscore (_).
    Mnemonics are standard C64 mnemonics, e.g. LDA. Arguments are parameters
    for the instruction, you can use the standard notation of address modes.
    In arguments you can also use symbolic constants, variables, and labels,
    decimal, binary or hexadecimal numbers and build complicated mathemathical
    expressions.
    There are also some special directives starting with a dot (.) to perform
    special tasks.

  4.2. Mathemathical Expressions
  ------------------------------
    In mathemathical expressions the following operands are allowed:
        name      value of the given symbolic constant, variable or label
        number    a decimal number (max. 65535)
        $number   a hexadecimal number (max. $FFFF)
        %number   a binary number (max. %11111111)
        "char"    the Ascii value of the character (This is PC-ASCII!)
        'char'    the character converted to Commodore PETSCII.
        *         current value of the PC (Program Counter),
                  the address, where the next instruction code will be stored.
    These are the operators with only one operand:
        -         sign change
        ~         bitwise NOT
        <         lower byte of word
        >         upper byte of word
    And these are the operators with two operands:
        +         addition
        -         subtraction
        *         multiplication
        /         division
        %         remainder or modulus
        &         bitwise AND
        |         bitwise OR
        ^         bitwise exclusive-OR (EOR, XOR)
        <<        shift left (by number of bits specified in second operand)
        >>        shift right (by number of bits specified in second operand)
    There are some relational operators, also with two operands:
    (The result is 1 if the relation is true, 0 otherwise.)
        =         equals to
        <>        not equals to
        <         less than
        <=        less than or equals to
        >         greater than
        >=        greater than or equals to

    All operators with two operands have the same precedence, and they are
    evaluated from left to right. Unary operators are evaluated first, and
    nested unary operators are evaluated from right to left. (From inner
    to outer in other words.)

    You can use parentheses to change the order of evaluation. Because the >>
    (shift right) operator can be confused with > (greater than) followed by
    the unary > (upper byte of word), you should always use parentheses in such
    cases. The same applies to << and < <. Parentheses can be nested
    practically at any depth. The C64's 6510 assembly language uses parentheses
    for some addressing modes, so if you want to use e.g. absolute indexed
    addressing mode and not indirect indexed, then make sure that the operand
    doesn't starts and ends with parenthesis. For example, instead of
    LDA (2+3)*(4+5),Y use LDA (2+3)*(4+5)+0,Y . The "+0" here doesn't change
    anything but ensures that the compiler will use the appropriate addressing
    mode.

    Some instructions like ROR and ROL allow accumulator addressing mode which
    is written with "A" as operand or with no operand at all. By these
    instructions "A" means the accumulator, but with other instructions it is
    treated as an absolute addressing mode with the value of the symbol "A".
    If no such symbol is defined, a compiling error occurs.

    Evaluation is always on word-size (16 bit) basis, so any overflow is
    truncated without carry. If the final result fits in one byte and the
    addressing mode allows it, then one-byte results are also used.

  4.3. Using Symbolic Names and the * Sign
  ----------------------------------------
    There are several types of symbolic names in the assembly language:
    constants, variables and labels. Constants and labels can be either local
    or global. There are some common rules for all symbolic names: they
    must start with a letter or with an underscore (_), followed by letters,
    numbers, or underscore characters. Their maximal length is 16 characters,
    any extra characters after the first 16 are ignored.
    If the name start with an underscore (_), it is a LOCAL name, otherwise it
    is GLOBAL. But variables can be only global ones.

    A label is a symbolic name of a memory location. This is the address of
    the instruction that follows the label. You can use these labels with any
    jump or branch intruction after and before this instruction.
    If a label doesn't start with underscore (_), then it is regarded as
    global label. Global labels may be defined only once during a compile and
    they can be used anywhere in the sources.
    If the label starts with _, then it is a LOCAL label. The scope of a
    local label is only between two neighboring defined global labels.
    So after defining a global label, you can define and use local labels
    but if you define another global label, than the previous local labels
    loose their validation afterwards. Now you can redefine these local
    variables under the same name which can be helpful, especially with
    loops.
    Note, that there are also SOURCE labels, which are defined with the .LABEL
    directive. They are used exclusively in .IF and .GOTO directives and they
    are totally different from the regular labels mentioned above.
    (See Section 4.4 below for more details about .LABEL)

    Symbolic constants can be declared with a line
        name = expression
    where expression is a valid mathemathical expression.
    Symbolic variables are very similar, but they are declared by
        name := expression
    The only difference between symbolic variables and constants, that
    (global) constants can be defined only once during a compilation.
    Variables can be redefined with a new value several times. The assembler
    uses always the result of the last definition. (However, if it is used
    before its first definition, the very last definition will be used.)
    If the name of a constant starts with an underscore, then it is a LOCAL
    constant. Similar rules apply to them as to local labels, so they are
    valid only between two global LABELS.

    Symbolic names can be used in any expression in an argument of an
    instruction or in a definition of another symbolic value. They can be
    also used before the line where they were declared. The only exception is,
    that in the definition of a constant or a variable only those constant
    and variable names can be used that were defined earlier.

    The * symbol is somewhat special. In an expression it means the current
    value of the Program Counter (or PC). That is the memory address where
    the next instuction will be placed. The PC is incremented by 1 - 3 bytes
    with every compiled instruction depending on the instruction's length.
    You can also control the place of the compilation by changing the value
    in *. To do this, a "* = value" line is needed. (You may use := as well.)
    You can also use * in both sides of the = sign. For example use
    * = * + 10 to leave a hole of ten bytes untouched space in your compiled
    code.

  4.4. Special Directives
  -----------------------
    By specifying special directives you can command the compiler to
    do special tasks.
    The supported directives are:

    .BYTE bytelist  Add sequence of bytes in the target C64 image file.
                    Separate the bytes with commas. Use any valid expression.
                    The values will be stored from the current address of *,
                    and * will be updated.

    .WORD wordlist  Same as .BYTE, but specify words. They will be stored in
                    lower byte, higher byte order.

    .ASC "string"   Similar to .BYTE, but the ASCII values (this is IBM PC's
                    ASCII!) of a sequence of characters will be stored.
                    The starting and ending double quotes are required, but
                    they are not put in the compiled file.

    .TEXT "string"  Same as .ASC, but the character codes are translated
                    to CBM-ASCII (PETSCII). Sometimes the conversion
                    cannot give satisfactory result, because there are
                    many codes that have no pair in the other code-set.)

    .SCRL "string"  Same as .TEXT, but the characters are converted to
                    Commodore 64 screen codes using the "lower case / upper
                    case" character set.

    .SCRU "string"  Same as .SCRL, but with the "upper case / graphics"
                    character set.

    .INCLUDE file   Include another source file, then continue compiling.
                    These source include files can be nested. You cannot
                    reference to those symbolic names in an include file
                    that are defined in its "parent" source file.
                    But the global definitions of the include file are made
                    available in the parent file and are listed in the
                    symbol table in the report file.

    .INCBIN file    Include a binary file in the target. The file must be
                    in PRG, T64 or P00 format with the right extension.
                    The file contents will be loaded to the proper address
                    stored in the header of the file.
                    * will be set to the next byte after the binary file.

    .LABEL sourcelabel
                    Defines a source label for .IF and .GOTO directives.
                    These "source labels" points to locations in the SOURCE
                    file. They are totally different from the global and local
                    labels that point to (memory) locations in the TARGET file.

    .GOTO sourcelabel
                    Unconditionally jumps to another line in the same source
                    file, which contain a .LABEL directive with the same
                    source label name. Be careful not to create endless loops.
                    The assembler stops when you want to jump (with .GOTO or
                    .IF) to a label more than 65535 times in the same source
                    file because an endless loop is very likely in that case,
                    but it may take several minutes while this prevention
                    steps in action.

    .IF expression .GOTO sourcelabel
                    Evaluates the given mathemathical expression and performs
                    a jump in source file (as .GOTO) if the result is nonzero.
                    Otherwise the following line will be assembled next.

    .END            This directive causes the compiler to immediately stop the
                    compile of the current source file. However, if it was an
                    include source file, the compile of the invoker source
                    file carries on.

    .ENTRY value    This option is obsolete from version 1.0a of C64ASM.
                    For backward compatibility it is simply ignored.

    .OPT options    Overrides command-line options.
                    Switch options can be followed by + to turn option on,
                    or by - to turn it off. When nothing follows, it means
                    to turn it on. Each option has the same meaning as the
                    command-line option with the same letter.
                    The switch options are:
                      S   Write symbol table to reportfile
                      L   Write compiling list to reportfile
                      M   Write memory map to reportfile and in a separate file
                      T   Write summary to reportfile
                      R   Same as SLMT (most detailed report)
                    There are also non-switch options to specify
                    filenames. Add a = and a filename after the option letter.
                    The filename options are:
                      O=filename  Specify name of compiled output file
                      R=filename  Specify name of report file
                      M=filename  Specify name of mapfile
                    The file format of the output file depends on the
                    extension of its name, as at command-line parameters.
                    Multiple options can be added to one .OPT line separated
                    by commas.

  5. Using the Disassembler (C64DISA)
  -----------------------------------
    If you start C64DISA without arguments, you will get a brief help
    about the available options.
    Options can be given preceded by / or - , except input and output
    filenames, which must be given without / or -.
    Lower and upper case letters mean the same.
    Multiple options can be given in a line.
    Each group of options must start with a / or - and must not contain spaces.
    The groups must be separated by one or more spaces.
    Don't group the /E, /$ and /-$ options with other options, because they
    need an argument.
    The order of options is unsignificant.

    Usage:  C64DISA inputfilename[.PRG] [outputfilename[.DIS]] [options]

    Options:
     /E=num     use the num-th entry in the T64 file (default: first)
     /I         write info about inputfile to screen (no disassembling)
     /X         create hex dump (no disassembling)
     /A         create ascii dump (no disassembling)
     /R         create assembly source
     /$hexnum-hexnum   specify the address range to disassemble/list
     /$hexnum   start from given address
     /-$hexnum  stop at given address
     /B         stop disassembling at first BRK instruction
     /L         stop disassembling at first illegal instruction
     /S         skip illegal instructions

    The name of the input file is mandatory, all other are optional.
    If you don't specify output filename, the base name of the input will
    be used with .DIS extension. The default extension for input file is
    .PRG and for output file is .DIS.
    If you specify .T64 as extension of the input file, the T64 tape file
    format will be supposed. You can specify with the /E option, which entry
    should be used in a tape file containing multiple C64 files. /E=1 means
    the first file and so on (if no /E is given, the first entry will be
    loaded.) The selected entry must have "normal tape file" type in the
    T64 file header.
    If the extension is .P00, then the input file must be in P00 file
    format. Otherwise PRG file format is supposed.

    The output file can be viewed by any ascii text viewer.
    By default, this is the disassembled list of all the machine language
    instructions in the input file. (??? means an illegal instruction code.)
    One line of the list will look like this:
       4000  A9 29     LDA #$29
    Here, 4000 is the hexadecimal address of this instruction in C64's memory.
    A9 is the instuction code, 29 is the argument (this is at the memory
    location $4001) and LDA #$29 is the disassembled mnemonic with the
    notation of address mode and argument. (Here # means immediate constant.)

    You can control the scope of the disassembling with the /$, /-$, /B,
    /L and /S options.
    /$ and /-$ must be followed by a hexadecimal address.

    If you specify the /R option, C64DISA generates the disassembled list in
    assembly source format, so you can recompile it with C64ASM later.
    The /$, /-$, /B and /L options can be also used with /R.

    If /A is given, ascii dump will be generated instead of disassembled list.
    One line of this dump will look like this:

    11C1 ³ .../..ÄÜ..Ü.Ä./../..¿@³..¿@Ä./Ä.SELECT DESTINATION SPRITE WITH +
    11C1 is the hexadecimal start address of this line. The next 64 characters
    are the ascii equivalents of the memory locations $4000 - $403F.
    C64DISA tries to substitute the CBM ASCII characters by an appropriate
    PC ASCII character, but if no meaningful replacement can be given, it
    prints a dot.

    If /X is given, hexadecimal dump will be generated.
    One line of this dump will look like this:
    4000 ³ A9 29 A0 40 20 08 40 60 8D FD 00 8C FE 00 A0 00 ³ _).@ .@Ä.Ä..Ä...
    4000 is the hexadecimal start address of this line. The next 16 numbers
    are the contents of the memory locations $4000 - $400F in hexadecimal.
    Then the same 16 bytes follows as ASCII characters. The substitution
    works the same as by the /A option.
    The /X option overrides the /A option.
    You can still use the /$ and /-$ options with /X or /A to give the
    starting and ending address of the list but /B, /L and /S options are
    ignored if /X or /A is given.

    If /I option is given, C64DISA writes the start and the end address
    of the input file. No list will be generated, all other given options
    will be discarded.

    Examples:
       C64DISA /S foo out /$5000 /-$5FFF
                               Disassembles only valid instuctions between
                               $5000 and $5FFF in foo.prg to out.dis
       C64DISA archon.t64 /x   Writes hexa dump of archon.t64 to archon.dis
       C64DISA archon /I       Writes info about archon.prg to screen.

    Just like C64ASM, C64DISA also returns a DOS error code. The current
    error codes:
       0: No Error
      21: Error in command-line parameters or /H was used
      22: Out of memory (very unlikely in real situations.)
      23: Cannot open input file (invalid filename or invalid file format)
      24: Cannot create output file

  5.1. Map file format
  --------------------
    The map file is an ascii textfile with a specific format. C64ASM always
    creates a valid map file, but it is more likely that you use map files
    for those programs that don't have the source, so in these cases you
    should make the map file with a text editor.
    Anything after a semicolon (;) is treated as comment and discarded.
    Empty lines are also accepted.
    All other lines should look like this:
      from - to  code  ; comment
    where "from" and "to" are memory addresses in decimal or hexadecimal
    (leaded by a $ in the latter case). If "from" is omitted then the
    start of the input file is assumed. Similarly, the default for the
    "to" field is the end of the input file. The two addresses define a
    memory region, whose content-type is given by "code", which can be
    one of the followings:
      E       empty region that was not written so no displaying is needed
      C       program code (valid instructions)
      B       byte sequence (e.g. created by the .BYTE directive) that
               should be printed in hexadecimal
      BD       same as B but the bytes should be printed in decimal
      BB       same as B but the bytes should be printed in binary
      W       word sequence (e.g. created by the .WORD directive) that
               should be printed in hexadecimal
      WD       same as W but the words should be printed in decimal
      T       PET-ASCII text that should be converted to IBM ASCII before
               displaying (e.g. created by the .TEXT directive)
      A       ASCII text that should printed without converision
               (e.g. created by the .ASC directive)
      SL      C64 screen codes in the lower case / upper case character set
      SU      C64 screen codes in the upper case / graphics character set

    If the from and to address are the same, you may use only one number
    but don't put - sign before or after it.
    A given memory location can be defined multiple times but only the last
    definition is valid. So using the default for "from" and "to" fields
    makes sense only once. If a region is not defined, it is treated as
    byte sequence (B) if the /X was given in the command-line, and Ascii
    text (A) if /A was given. Otherwise the default is code (C).

  6. Using the BAS2TXT Utility
  ----------------------------
    BAS2TXT converts files in CBM BASIC format (pointers to next line, line
    numbers and tokenized line contents) to plain ascii textfiles. If you
    have C64 assembly source files in that format, you should convert them to
    textfile, so C64ASM can assemble them.

    If you start BAS2TXT without arguments, you will get a brief help
    about the available options.
    Options can be given preceded by / or - , except input and output
    filenames, which must be given without / or -.
    Lower and upper case letters mean the same.
    Multiple options can be given in a line.
    Each group of options must start with a / or - and must not contain spaces.
    The groups must be separated by one or more spaces.
    Don't group the /E option with other options, because it needs an argument.
    The order of options is unsignificant.

    Usage:  BAS2TXT inputfilename[.PRG] [outputfilename[.TXT]] [options]

    Options:
     /E=num     use the num-th entry in the T64 file (default: first)
     /L         don't put line numbers in output
     /P         don't convert text in quotes to PC ASCII
     /S         don't put spaces before and after BASIC commands
     /:         put commands separated by colon (:) in new lines

    The name of the input file is mandatory, all other are optional.
    If you don't specify output filename, the base name of the input will
    be used with .TXT extension. The default extension for input file is
    .PRG and for output file is .TXT.
    If you specify .T64 as extension of the input file, the T64 tape file
    format will be supposed. You can specify with the /E option, which entry
    should be used in a tape file containing multiple C64 files. /E=1 means
    the first file and so on (if no /E is given, the first entry will be
    loaded.) The selected entry must have "normal tape file" type in the
    T64 file header.
    If the extension is .P00, then the input file must be in P00 file
    format. Otherwise PRG file format is supposed.

    If you want to compile the output of BAS2TXT with C64ASM use the /L, /S
    and the /: options, because C64ASM doesn't allow line numbers and colons
    in an assembly sourcefile and tokenized BASIC commands may be part
    of symbols so separating spaces may cause compiling errors.
    When you convert sources with .ASC directives in it, the /P option
    may also come handy, because C64ASM interprets .ASC as PC-ASCII, so
    it leaves the codes unchanged.
    For example, to convert a source file in C64SRC to plain text, use
      BAS2TXT CHRE2ASM.T64 CHRE2.ASM /LPS:

    BAS2TXT returns the same DOS error codes as C64DISA. (See Section 5.)

  7. Revision History
  -------------------
    Version 1.1a (released on 8 November, 2001)
    ------------
    ALL PROGRAMS:
      - Modified: The package became FREEWARE, not shareware as before.
      - Fixed: the infamous Borland Pascal bug that caused Runtime error
          on machines with a too fast CPU.
      - Modified: DOS error codes restructured and fully documented.
          (See Section 3.1)
      - The release contains a very early version of integrated development
           environment based opn Turbo Vision.
    C64ASM:
      - Labels can be put in empty lines as well
      - Added /M and /M=filename options to create a memory map
      - Added /R option (without filename) to create detailed report (as /SLMT)
    C64DISA:
      Still missing:
      - /M and /M=filename options for memory map support
          (See Section 5.1)

    Version 1.1: (Released on February 5, 1996)
    ------------
      - Added new BAS2TXT utility.
      - Added C64SRC.ZIP: Assembly source files of two C64 programs:
          Bali's Sprite Designer 4.0 and Bali's Character Editor 2.0
          The sources are in their original format, but with minimal work
          they can be compiled with C64ASM as well. C64SRC is freeware.
    BOTH PROGRAMS (C64ASM & C64DISA):
      - Fixed bug: in DEC and INC instructions the Absolute,X addressing
          mode was mistyped to Absolute,Y.
      - Fixed: the T64 file loader was too strict and refused to load T64 files
          that had the "number of used directory entries" set to zero in their
          header. Now these files can be loaded, too. But the loading of T64
          files with a corrupted header (for which C64S also displays a
          "?LOAD ERROR") fails.
      - Added P00 file format support (The file format of "Personal C64".)
    C64ASM:
      - Fixed bug: the assembler always enforced usage of zero page address
          modes when the operand was less then $0100. This resulted an error
          message when only absolute address mode was available, e.g. STA $40,Y
      - Fixed: This manual falsely stated that the precedence of operators
          in mathemathical expression is "as usual". Actually all operators
          have the same precedence for simplicity.
      - Fixed: if a symbol is defined more times in different include source
          files, the symbol table now lists it only once.
      - Added /0 option to enforce P00 file format for output file even if
          no output filename (with .P00 extension) is specified.
      - Added local labels and constants. (They are starting with _ and are
          valid only between neighboring global labels only.)
      - Added .INCBIN directive to put a binary file in the target.
      - Added .LABEL, .GOTO and .IF directives to jump to another line in the
          same source file (depending on an expression or unconditionally)
      - Added .END directive to end the compiling of the current source file.
      - Added .TEXT, .SCRL and .SCRU directives to put PETSCII codes and
          Commodore screen codes in the target. (The already existing .ASC
          doesn't make any conversion.)
      - Added relational operators ( =, <>, <, >, <=, >= ) in mathemathical
          expressions. Result is 1 if true, 0 otherwise.
      - Added unary 'char' operator for PETSCII interpretation of a character.
          (The ending quote is required also in the "char" operator.)
      - Modified: shift left & right operators became << and >> instead of
          < and > in mathemathical expressions.
      - Modified: Report is more detailed for include files: a line-by-line
          compiling list and the list of the included filenames are added, and
          you get a more helpful error message when threre is an error in an
          include file.
      - Modified: Some minor enhancements in the report file.
      - Modified: The .OPT directive can be used in included source files, too.
      - Modified: the whole C64 memory is filled with zero before compiling, so
          any untouched region, that must be put in the target file, contains
          zeros not random numbers.
      - Added some additional small example source files, the older ones were
          also modified.
    C64DISA:
      - Added /E option to load other than the first entry from a T64 file.
          (Note: in Version 1.0 the /E option had different meaning.)
      - Added /R option for "re-source" function: the so generated disassembled
          list is in assembly format, so you can recompile it with C64ASM
          later. I still want to improve this function with map file support
          and automatic labelling.
      - Added translation of CBM ASCII to PC ASCII in hex and ascii dump.

    Version 1.0a: (Released on December 10, 1995)
    -------------
    ALL PROGRAMS:
      - Fixed bug: while disassembling branch instructions, the reported
          target address was 2 less than the correct one. C64ASM assembled
          correctly, but in the reportfile the disassembled result was also
          wrong.
      - Added PRG file format support. My MEM format is no longer supported.
    C64ASM:
      - Fixed: This manual falsely stated that the "bitwise not" operator is
          called "NOT". Actually it is the tilde (~) symbol.
      - Added /6 option to enforce T64 tape file format for output file even if
          no output filename (with .T64 extension) is specified.
      - Added indication on screen if a reportfile has been created.
      - Modified: Symbols may start also with an underline (_), and they may
          contain letters, numbers and underline from the second character.
          (From v1.1 if the first character of a label is _ then it is local.)
      - Deleted .ENTRY directive. (It was needed only with MEM file format.)
          For compatibility, this directive is ignored by the assembler.
      - Added HELLOW.ASM example assembly source file.
    C64DISA:
      - Fixed bug: the ascii dump routine overran near $FFFF adresses.
      - Added: Start and end addresses for disassembling can be given in one
          single option, for example /$4000-403F.
      - Added displaying of the start and end adresses of the requested list,
          not only the extents of the whole programfile.
      - Deleted /E option. (It was needed only with MEM file format.)
          (Note: from Version 1.1 the /E option gets a different meaning.)

    Version 1.0: (Released on September 4, 1995)
    ------------
      - This was the first public release, but most of the code I wrote in
          1993. Only T64 file format support was added in 1995 just before the
          first public release.

  8. Planned Features in a Next Release
  -------------------------------------
    There are several features I would like to add to this program package,
    but unfortunately I didn't manage to find enough time for them yet.
    Some examples:
    - Multiple output file support
    - Improved re-sourcer function in C64DISA with map files and labelling.
    - Reverse direction of BAS2TXT
    - True mathemathical precedence in expressions. I did it already in my
      other programs, just some porting would be needed, but I'm not sure that
      the whole thing worth the time and the more complicated code.

  9. Other Programs Available from the Same Author
  ------------------------------------------------
    There are some other shareware and freeware programs available from
    the same author:
      - BALI'S CALC  - a Simple Scientific Calculator Program with
                        ( ) x^y x! Pi Deg Rad Sin & Arcs, Ln Exp Mem
                        Ran SCI BackSpace & more. DOS text mode,
                        keyboard and/or mouse control (FREEWARE).
      - FORMULA v2.0 - a Mathemathical Expression Evaluating Program
                        with about 100 - 100 built-in contants and functions,
                        and a constant and function editor, where you can
                        define and save your own set. (FREEWARE)
      - STEFI v1.0c  - a Graph Editor and Analyser Program
                        where you can edit mathemathical graphs and analyse
                        them in detail: matrices, components, Prufer code,
                        minimal cost path and tree, excentricity, center,
                        topologic order, strong components & more. (FREEWARE)
      - C64PROGS     - Two Commodore 64 programs written in pure assembly.
                         - Bali's Sprite Designer 4.0
                         - Bali's Character Editor 2.0
                        In T64 tape file format. A C64 emulator (or a real C64)
                        is required. (FREEWARE)
      - DOSINFO v1.3 - Information about dos, disks and more (FREEWARE)
      - PRIMES       - List of prime numbers and prime factorization (FREEWARE)
      - ASCII TEXTFILE MASTER  - A commandline-driven ascii textfile processor
                        with margins, automatic page breaks, header & footer,
                        justify, include files, symbolic defines, print merge
                        and more. Manual only in Hungarian. (FREEWARE)

    These programs are available on the World Wide Web at
      http://tothb.ehc.hu/software

  10. Contacting the Author
  ------------------------
    I am always glad when receiving any feedbacks about my programs.
    If you are satisfied :-), please let me know.
    If you find it useless :-(, poor or disappointing, or just made a
    much better one, please don't hesitate to write me that, too.
    If you find any bugs :-(, please report them to me.
    If you have any suggestions for further improvements, I will
    appreciate them as well.
    If you are interested in getting the source code of this or other
    programs made by me, contact me for details.

    Contact me via email: tothbali@mailbox.hu
